\subsection{Data Loading}\label{ssec:dl}
The data loading phase   loads logs  serialized in multiple  formats, thus uncluding the XML-based XES standard, a tab-separated events' activity labels, and the \textsc{Human Readable Log Format} firstly introduced in \cite{bpm21}. We use different data parsers, which are still linked to the same data loading primitives. 

If the log does not contain data payloads, the entire log can be represented into two relational tables, \textsf{CountingTable(ActId,TraceId,Count)} and \textsf{ActivityTable(ActId,TraceId,EventId,\\PrevEvent,NextEvent)}. While the former counts the occurrence of each activation label in $\Sigma$ for each trace, the latter lists all of the possible events similarly to SQLMiner. Both tables compactly represent the initial three columns as a 64-bit unsigned integer, which is also used to sort the tables in ascending order. A row $\braket{\textsf{a},j,h}$ from \textsf{CountingTable} states that there are $h$ events exhibiting the activity label $\textsf{a}$ in the trace $\sigma^j$; each row $\braket{\textsf{a},j,i,q,q'}$ from \textsf{ActivityTable} states that the $i$-th event of the $j$-th trace ($\sigma^j_i=\braket{\textsf{a},p}$) is labelled as $\textsf{a}$, while $q$ (or $q'$) is the pointer to the immediately preceding $\sigma^j_{i-1}$ (or  following, $\sigma^j_{i+1}$) event within the trace, if any. As seen from \figurename~\ref{fig:knobab_pipeline}, the selected block for the \textsf{ActivityTable} highlights this structure, where NULL for a given row regards  the start (finish) event of each trace, where there is no possible reference to past (future) events. Trace payload information is injected (as an event) before the first event, which is also contained. Therefore, all trace payload events contain NULL in all of their previous fields.


If, on the other hand, the log is associated to either trace or event payloads, we exploit 
the query and memory efficient  column-based model \cite{IdreosGNMMK12}, thus representing all of the values $v$ associated to a  payload key $k$ within the rows from  \textsf{AttributeTable$k$}. In our implementation, each row $\braket{\textsf{a},v,i}$ from  \textsf{AttributeTable$k$(ActId,Value,Offset)} represents a value $v$ associated to the key $k$ from an event stored as the $i$-th row from \texttt{ActivityTable}. To perform payload-based queries efficiently, the table is sorted in ascending order by the  three columns. As each data condition is always associated to a given activity label, those can be effectively run as data range queries run via binary search algorithms. From \figurename~\ref{fig:knobab_pipeline}, all the attributes are stored in distinct tables. The value column can contain multiple data types, but each attribute is associated to only one type. When decomposed atoms are used for a query, the tables associated to the query are then accessed. The offset value can then determine the location within the \textsf{ActivityTable} where this event occurred, providing the trace id and event id required for the intermediate representation.

\textsf{CountingTable} is mainly accessed for existential and \textsf{Exists} and \textsf{Absence} templates where no data payload is specified, while  \textsf{ActivityTable} is  used for either returning all of the events within the log associated to a given activity label, or returning all of the events happening at either the beginning or at the end of a trace. Each table \textsf{AttributeTable$k$}, on the other hand, will %accessed for 
return all the events satisfying a given condition associated to a specific %data 
key $k$. %As each data condition is always associated to a given activity label, each value is grouped by activity label via table ordering.

After loading the whole dataset, the number of the traces within the log ($|\mathcal{L}|$), the length $\ell_j$ for each trace $\sigma^j$, and the number of distinct activity labels ($|\Sigma|$) is known. Given this, we can get the number of occurrences of each $i$-th activity label from $\Sigma$ in each trace by directly accessing the rows within the \textsf{CountingTable} within the range $[|\mathcal{L}|\cdot (i-1) + 1,\; |\mathcal{L}|\cdot i]$.
%we can determine the number of occurrences of each $i$-th activity label in $\Sigma$ for each trace $\sigma^j\in\mathcal{L}$ by accessing the rows from  without the need of any external indexing data structure. 
On the other hand, the loading and and indexing phase generates an \textsf{ActivityTable} associated to two indices, a primary index and a secondary index. While the former allows to effectively return all of the events associated to a specific activity label, the latter is used to access to either the first and to the last event in a trace. If required, pointers associated to each record allow temporally scanning the traces as a double linked list. From \figurename~\ref{fig:knobab_pipeline}, the offset for the third event (B) in the \textsf{CountingTable} can then be calculated by would be $[3 \cdot (3-1) + 1, 3 \cdot 3] = [7,9]$. Given that this counting table computes only for untimed operations, the intermediate result for untimed \textsf{Exists}$(1,B,\textbf{true})$ within this range are provided as $\Set{\braket{1,1,\emptyset}, \braket{2,1,\emptyset}}$, as the third trace never contains a B, therefore is not included in the result.
Details of the loading and indexing phase are omitted due to the page limits.



