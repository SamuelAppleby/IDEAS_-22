\section{Logical Model}

\subsection{(Intermediate) Result Representation}
Within the computation pipeline, (intermediate) results are represented as a set of triplets $\braket{i,j,L}$ representing that, starting from event $\sigma^i_j$ in trace $\sigma^i$, we might observe activation, target, or correlation conditions in an ordered vector $L$.  While for activation and target %, and correlation conditions are represented as distinct tagged unions, where for the first two 
we %only 
preserve 
the matched event id,
%the single event id information while, for the last one, we recall 
correlations stores
%<<<<<<< nosam
both the activation and the target condition leading to the satisfaction of a given $\Theta$ predicate. This is a sensible representation, as per declarative constraints it may exist only one possible $\Theta$ predicate accessing activations' and targets' payloads. Such triplets are sorted by trace id and event id, and operators manipulating those (\S\ref{sec:xltlf}) guarantee that only one triplet should appear per unique trace and event id. This guarantees efficient join operations across different intermediate results, as well as efficient counting of the satisfied conditions for each trace. While the former might be implemented via sorted joins, the latter can be achieved by either binary search operations or by look-ahead jumps, as the events pertaining to a trace are contiguous  \texttt{\color{red}[TODO: infographic link]}.
%=======
%both the activation and the target condition leading to the satisfaction of a given $\Theta$ predicate. This is a sensible representation, as per declarative constraints it may exist only one possible $\Theta$ predicate. Such triplets are sorted by trace id and event id, and operators manipulating those (\S\ref{sec:xltlf}) guarantee that only one triplet should appear per unique trace and event id. This guarantees efficient join operations across different intermediate results, as well as efficient counting of the satisfied conditions for each trace. While the former might be implemented via sorted joins, the latter can be achieved by either binary search operations or by look-ahead jumps, as the events pertaining to a trace are contiguous. Ã¹
As seen from \figurename~\ref{fig:knobab_pipeline}, \DeclareClauseWithJoin{Choice}{A}{true}{B}{$y < 0$}{$\texttt{A}.x < \texttt{B}.y$} needs to access the indexed tables for the target and activation data. Here, all events associated to the activity label \texttt{A} are retrieved from the \textsf{ActivityTable} as the activation conditions. The selected rows are then converted into the intermediate result representation, which are $\Set{\braket{1,2,\{A(2)\}}, \braket{1,5,\{A(5)\}}, \braket{2,3,\{A(3)\}}, \braket{3,4,\{A(4)\}}}$ where, as we are going to see in the next paragraph, A is the container of matched activation conditions. 
%>>>>>>> main

Our proposed representation is different from the one provided by \cite{BurattinMS16} which can only be suited for representing final results. The authors exploit 
%This representation is different from the result representation from , where the data structure of choice for representing the results is 
a hash map of hash maps, associating  each trace to the collected activation conditions which, in turn, might be associated to further target conditions. %Still, in 
This does not associate trace events to satisfied conditions that might occur in the future: %representation, no trace temporal representation is provided while, 
as observed in \S\ref{sec:DAD}, this information is required for checking the satisfiability of $\varphi$ while jointly visiting both the trace and the formula. This other representation cannot be used in our scenario, where we need to retain the activation and the target conditions that were tested and then collected after a given trace event.



\subsection{\xLTLf operators}\label{sec:xltlf}

We now propose the set of operators that is directly exploited by our pipeline:
\[\begin{split}
\phi:=&\;\;\;\textsf{Init}_{A/T}(A,p)\gsep\textsf{End}_{A/T}(A,p)\gsep\textsf{Exists}_{A/T}(n,A,p)\gsep\textsf{Absence}_{A/T}(n,A,p)\\
     &\gsep \textsf{Next}(\phi)\gsep \textsf{Globally}(\phi)\gsep \textsf{Future}(\phi)\gsep \textsf{Not}(\phi)\\
     &\gsep \textsf{Or}(\phi,\phi',\Theta)\gsep \textsf{And}(\phi,\phi',\Theta)\gsep \textsf{Until}(\phi,\phi',\Theta)\\
     &\gsep \textsf{AndGlobally}(\phi,\phi',\Theta)\gsep \textsf{AndFuture}(\phi,\phi',\Theta)\gsep \textsf{AndNextGlobally}(\phi,\phi',\Theta)\\
\end{split}\]

Operators in the first line filter traces' events and represent these into the previously-described result representation. 
%The first line of operators represent the ones directly accessing the event trace information and transforming the trace representation of choice into the previously-described result representation. In particular, we are going to outline our proposed trace representation via multiple representation tables in \S\ref{ssec:dl}. 
E.g., \textsf{Init} (\textsf{End}) returns the events at the beginning (end) of each trace satisfying the condition $A\wedge p$. Similarly to \cite{BurattinMS16}, each of these operators might be expressed as either an untimed or as a timed specification. While the timed definition returns a tuple $\braket{i,j,L}$ for each possible event $\sigma^i_j$ within the trace $\sigma^i$ where the formula holds, the untimed specification only checks whether the formula holds at the beginning of the trace. E.g., untimed \textsf{Exists} (\textsf{Absence}) returns the first event trace if at least $n$ (at most $n-1$) events satisfy $A\wedge p$, while the timed version returns the events satisfying (not satisfying) $A\wedge p$ (always $n=1$). All of these operators might be optionally marked as returning either an activation ($A$) or a target ($T$) condition, so that each  $\braket{i,j,L}$ triplet has $L=\{A(j)\}$ or $L=\{T(j)\}$; when no mark is specified, $L$ is empty.

The next two lines report the same operators described in \S\ref{sec:DAD} with the addition of the explicit correlation conditions over activation and target conditions for each binary operator. Algorithm~\ref{algo:xltlfAlgo} provides  implementations of the timed versions of such operators, due to lack of space untimed versions are not provided, yet available in our code base: please observe that $\textsf{Next}(\phi)$ keeps unaltered the activation and target conditions from $\phi$ and just returns the events where $\phi$ happens as a subsequent step. The \textsf{And} (and \textsf{Or}) operator can be expressed as a (full-outer-)$\Theta$-join algorithm over the activation and target conditions stored in $L$ associated to the same event. If at least one activation condition matches one target condition from the same event, those are expressed as a marked correlation condition $M(i,j)$ which is then returned by the join. Regarding the same \textsf{Choice} clause from \figurename~\ref{fig:knobab_pipeline}, the correlation condition $\Theta$ associated to \textsf{Or} is then computed for each activation/target match, and if the condition is passed, the resulting match is added to $L$. 


The remaining operators merge multiple operators together when %it is possible to find 
a specific implementation outperforms%ing 
the execution of the operators separately:
 %each single operation: 
 e.g., $\textsf{AndGlobally}(\phi,\phi',\Theta)$ is equivalent to $\textsf{And}(\phi,\textsf{Globally}(\phi'),\Theta)$, but preliminary experiments reveal that the former has a more efficient implementation than computing the latter. This choice was inspired by relational algebra, where $\theta$-joins are usually more efficient than performing a join and a selection operation separately.
 On the other hand, % Similarly,  we can associate the correlation condition to implication operators after rewriting 
 $\textsf{Implies}(\phi,\phi',\Theta)$ is rewritten as $\textsf{Or}(\textsf{Not}(\phi),\,\textsf
{And}(\phi,\phi',\Theta),\,\textbf{true})$.

%The first line refers to the operators that are going to directly access the tables, thus converting the tabular representation into a 

Each \xLTLf operator is going to both return and/or accept data in the result representation, thus making such operators closed on such format.

%Algoritms \ref{algo:xltlfAlgo}. \texttt{\color{red}[TODO: \xLTLf Operators]} 

%\begin{mdframed}[hidealllines=true,backgroundcolor=orange!20]
%	{$\color{red}\ostar$} On the other hand, \xLTLf operators are associating both or and and operators to such operators, thus allowing the implementation of the and (or) operator as a (full-outer) join algorithms. 
%\end{mdframed}




\begin{algorithm}
	\caption{\xLTLf pseudocode implementation for the basic timed operators}\label{algo:xltlfAlgo}
	
	
	\begingroup % trick algorithm2e into thinking we're in one column mode
	\csname @twocolumnfalse\endcsname
	\noindent
	\resizebox{\textwidth}{!}{%
		\begin{minipage}{1.3\textwidth}
			%%%%%%%%%%%%%%
			\begin{algorithmic}[1]
				\Statex
				\Function{Future}{$\phi$}
				\State {\textbf{Require:\;}sorted($\phi$)}
				\ForAll{$\braket{t,e,L}\in\phi$}
				\textbf{yield} $\braket{t,e,\bigcup\Set{L'|\braket{t,e',L'}\in\phi\texttt{\textbf{\;and\;}}e'\geq e}}$
				\EndFor
				\EndFunction\medskip
				%%
				\Function{Globally}{$\phi$}
				\State {\textbf{Require:\;}sorted($\phi$)}
				\ForAll{$\braket{t,e,L}\in\phi$}
				\State $E\gets\Set{e'|\braket{t,e',L'}\in\phi\texttt{\textbf{\;and\;}}e'\geq e}$
				\If {$|E|=\ell_t-e$} 
				\textbf{yield} $\braket{t,e,\bigcup\Set{L'|\braket{t,e',L'}\in\phi\texttt{\textbf{\;and\;}}e'\in E}}$
				\EndIf
				\EndFor
				\EndFunction\medskip
				%%
				\Function{Next}{$\phi$}
				\State {\textbf{Require:\;}sorted($\phi$)}
				\ForAll{$\braket{t,e,L}\in\phi$\textbf{\;s.t.} $e>1$}
				\textbf{yield} $\braket{t,e-1,L}$
				\EndFor
				\EndFunction\medskip
				%%
				\Function{CommonJoin}{$\phi,\phi',\Theta,{isDisjunctive}$} %\Comment{Sort Merge (Full-Outer-)Join}
				\State {\textbf{Require:\;}sorted($\phi$)\textbf{\;and\;}sorted($\phi'$)}
				\State  $it\gets$\textbf{Iterator}$(\phi), it\gets$\textbf{Iterator}$(\phi')$
				\While{$it\neq\emptyset$\textbf{\;and\;}$it'\neq\emptyset$}
				\State $\braket{t,e,L}\gets\texttt{current}(it)$, $\braket{t',e',L'}\gets\texttt{current}(it')$
				\If{$t=t'$ \textbf{and} $e=e'$}
				\If{$L=\emptyset$} $L''\gets L'$
				\ElsIf{$L'=\emptyset$} $L''\gets L$
				\Else 
				\State $L''\gets\emptyset$
				\ForAll{$m\in L$\textbf{\;and\;}$n\in L'$\textbf{\;s.t.\;}$\Theta(m,n)$}
				\State $L''\gets L''\cup\Set{\textbf{join}[m,n]}$
				\EndFor
				\EndIf
				\State \textbf{yield} $\braket{t,e,L''}$; $\texttt{next}(it)$; $\texttt{next}(it')$; 
				\ElsIf{$t<t'$\textbf{\;or\;}($t=t'$\textbf{\;and\;}$e<e'$)} 
				\If  {$isDisjunctive$} \textbf{yield} $\braket{t,e,L}$  \EndIf
				\State $\texttt{next}(it)$
				\Else 
				\If  {$isDisjunctive$} \textbf{yield} $\braket{t',e',L'}$  \EndIf
				\State $\texttt{next}(it')$
				\EndIf
				\EndWhile
				\EndFunction\medskip
				%%
				\Function{And}{$\phi,\phi',\Theta$}
				\Call{CommonJoin}{$\phi,\phi',\Theta,\textbf{false}$}
				\EndFunction\medskip
				%%
				\Function{Or}{$\phi,\phi',\Theta$}
				\Call{CommonJoin}{$\phi,\phi',\Theta,\textbf{true}$}
				\EndFunction\medskip
				%%
				\Function{Until}{$\phi,\phi',\Theta$}
				\State {\textbf{Require:\;}sorted($\phi$)\textbf{\;and\;}sorted($\phi'$)}
				\ForAll{$t$ \textbf{\;s.t.\;} $\braket{t,i',L'}\in \phi'$}
				\State $\alpha\gets 0$; $Map\gets\{\}$
				\ForAll{$\braket{t,i,L}\in\phi'$}
				\While{$i<\alpha$}
				\If{$\braket{t,\alpha,L_\alpha},\braket{t,\alpha+1,L_{\alpha+1}},\dots,\braket{t,i-1,L_{i-1}}\in\phi,$\\\textbf{\;and\;}$\Theta(\alpha,j)$\textbf{\;for all\;}$j\in L_\alpha\cup\dots\cup L_{i-1}$}
				\State $Map[i]\gets\Set{\texttt{\textbf{join}[k,i]}|k\in L_\alpha\cup\dots\cup L_{i-1}}$
				
				\EndIf
				\EndWhile
				\State $Map[i]\gets Map[i]\cup L$; 
				\ForAll{$i\in \texttt{mapKey}(Map)$} \textbf{yield} $\braket{t,i,Map[i]}$
				\EndFor
				\EndFor
				\EndFor
				\EndFunction\medskip
			\end{algorithmic}
			%%%%%%%%
		\end{minipage}%
	}% <------------- end of \resizebox
	\endgroup
\end{algorithm}