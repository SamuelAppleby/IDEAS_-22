\section{Logical Model}
\subsection{XES Log Model}\label{sec:XES}

\texttt{\color{red}[TODO: simplify, remove unnecessary logical notation] } (Data) \textit{payloads} are maps  associating attributes (i.e., \textit{keys}) to data values. %We consider also the case in which the value of a certain key $k$ is missing in a payload. In particular, we denote as $\varepsilon$ an element $\varepsilon\notin V$, such that $p(k)=\varepsilon$ for $k\notin\textup{dom}(p)$. 
Given a finite set of activity labels $\textsf{Act}$, an event $\sigma_j^{i}$ is a pair $\Braket{\textsf{a},p}$, where $\textsf{a}\in\textsf{Act}$ is an activity label, and $p$ is a payload. %; we denote with $\lambda$ (and $\varsigma$) the first (and second) projection of such pair, i.e., $\lambda(\sigma_j^{i})=\texttt{A}$ (and $\varsigma(\sigma_j^{i})=p$). 
A \textit{trace} $\sigma^i$ is a temporally-ordered and finite sequence of distinct events $\sigma^i=\sigma_1^i\cdots\sigma_n^i$, modeling a process run. %We distinguish the trace keys ($K_t$) from the event keys ($K_e$), such that $K=K_t\cup K_e$ with $K_t\cap K_e=\emptyset$: 
all events within the same trace associate the same values to the same trace keys. %, i.e., $\forall \Braket{\texttt{A}_i,p_i},\Braket{\texttt{A}_j,p_j}\in\sigma.\;\forall k\in K_t.\; p_i(k)=p_j(k)$. 
A log $\mathcal{L}$ is a finite set of traces $\Set{\sigma^1,\dots,\sigma^m}$. We denote  $\Sigma\subseteq\textsf{Act}$ as the set of all the possible activity labels in the log. If traces also contain a payload, then this can be easily mimicked by adding an extra event containing such a payload, \textsf{\_\_trace\_payload}, at the beginning of the trace. This  characterization \cite{bpm21} is compliant with the \textsc{eXtensible Event Stream} (XES) format, which is the \textit{de facto} standard for representing event logs within the Business Process Management community \cite{XES}. Please refer to \S\ref{ssec:dl} for the representation of each log as a separated in-memory database.

\subsection{Result Representation}
\texttt{\color{red}[TODO: each event in the data input can be represented as a single record, which consists of...] That is the Logical Model representation of the data}

\section{\xLTLf operators}\label{sec:xltlf}
Algoritms \ref{algo:xltlfAlgo}. \texttt{\color{red}[TODO: \xLTLf Operators]} 

\begin{mdframed}[hidealllines=true,backgroundcolor=orange!20]
	{$\color{red}\ostar$} On the other hand, \xLTLf operators are associating both or and and operators to such operators, thus allowing the implementation of the and (or) operator as a (full-outer) join algorithms. By doing so, we can also associate the correlation condition to implication operators after rewriting $\varphi\Rightarrow_\Theta\varphi'$ as $(\neg\varphi)\vee(\varphi\wedge_\Theta\varphi')$.
\end{mdframed}

\begin{itemize}
	\item What is the input and output format for all of the operators
	\item What does the sorting assumption guarantee at the operators' implementation level
	\item Discuss the data operators at the leaf level for accessing data, and how do we guarantee to preserve such representation.
	\item Describe the intuition over each operator
\end{itemize}