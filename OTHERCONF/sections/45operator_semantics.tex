
\begin{algorithm}
	\caption{LTL$_f$ pseudocode implementation for the basic timed operators}


\begingroup % trick algorithm2e into thinking we're in one column mode
\csname @twocolumnfalse\endcsname
\noindent
\resizebox{\textwidth}{!}{%
	\begin{minipage}{1.3\textwidth}
%%%%%%%%%%%%%%
	\begin{algorithmic}[1]
		\Statex
\Function{Future}{$\varphi$}
		\State {\textbf{Require:\;}sorted($\varphi$)}
		\ForAll{$\braket{t,e,L}\in\varphi$}
		 \textbf{yield} $\braket{t,e-1,\bigcup\Set{L'|\braket{t,e',L'}\in\varphi\texttt{\textbf{\;and\;}}e'\geq e}}$
		\EndFor
\EndFunction\medskip
%%
\Function{Globally}{$\varphi$}
		\State {\textbf{Require:\;}sorted($\varphi$)}
		\ForAll{$\braket{t,e,L}\in\varphi$}
		\State $E\gets\Set{e'|\braket{t,e',L'}\in\varphi\texttt{\textbf{\;and\;}}e'\geq e}$
		\If {$|E|=\ell_t-e$} 
		 \textbf{yield} $\braket{t,e-1,\bigcup\Set{L'|\braket{t,e',L'}\in\varphi\texttt{\textbf{\;and\;}}e'\in E}}$
		 \EndIf
		\EndFor
\EndFunction\medskip
%%
\Function{Next}{$\varphi$}
		\State {\textbf{Require:\;}sorted($\varphi$)}
		\ForAll{$\braket{t,e,L}\in\varphi$\textbf{\;s.t.} $e>1$}
		\textbf{yield} $\braket{t,e-1,L}$
		\EndFor
\EndFunction\medskip
%%
\Function{CommonJoin}{$\varphi_1,\varphi_2,\Theta,{isDisjunctive}$} %\Comment{Sort Merge (Full-Outer-)Join}
	\State {\textbf{Require:\;}sorted($\varphi_1$)\textbf{\;and\;}sorted($\varphi_2$)}
	\State  $it\gets$\textbf{Iterator}$(\varphi_1), it\gets$\textbf{Iterator}$(\varphi_2)$
	\While{$it\neq\emptyset$\textbf{\;and\;}$it'\neq\emptyset$}
	\State $\braket{t,e,L}\gets\texttt{current}(it)$, $\braket{t',e',L'}\gets\texttt{current}(it')$
	\If{$t=t'$ \textbf{and} $e=e'$}
	\If{$L=\emptyset$} $L''\gets L'$
	\ElsIf{$L'=\emptyset$} $L''\gets L$
	\Else 
	\State $L''\gets\emptyset$
	\ForAll{$m\in L$\textbf{\;and\;}$n\in L'$\textbf{\;s.t.\;}$\Theta(m,n)$}
	\State $L''\gets L''\cup\Set{\textbf{join}[m,n]}$
	\EndFor
	\EndIf
	\State \textbf{yield} $\braket{t,e,L''}$; $\texttt{next}(it)$; $\texttt{next}(it')$; 
	\ElsIf{$t<t'$\textbf{\;or\;}($t=t'$\textbf{\;and\;}$e<e'$)} 
	\If  {$isDisjunctive$} \textbf{yield} $\braket{t,e,L}$  \EndIf
	\State $\texttt{next}(it)$
	\Else 
		\If  {$isDisjunctive$} \textbf{yield} $\braket{t',e',L'}$  \EndIf
		\State $\texttt{next}(it')$
	\EndIf
	\EndWhile
\EndFunction\medskip
%%
\Function{And}{$\varphi_1,\varphi_2,\Theta$}
	\Call{CommonJoin}{$\varphi_1,\varphi_2,\Theta,\textbf{false}$}
\EndFunction\medskip
%%
\Function{Or}{$\varphi_1,\varphi_2,\Theta$}
\Call{CommonJoin}{$\varphi_1,\varphi_2,\Theta,\textbf{true}$}
\EndFunction\medskip
%%
\Function{Until}{$\varphi_1,\varphi_2,\Theta$}
\State {\textbf{Require:\;}sorted($\varphi_1$)\textbf{\;and\;}sorted($\varphi_2$)}
\ForAll{$t$ \textbf{\;s.t.\;} $\braket{t,i',L'}\in \varphi_2$}
\State $\alpha\gets 0$; $Map\gets\{\}$
\ForAll{$\braket{t,i,L}\in\varphi_2$}
\While{$i<\alpha$}
\If{$\braket{t,\alpha,L_\alpha},\braket{t,\alpha+1,L_{\alpha+1}},\dots,\braket{t,i-1,L_{i-1}}\in\varphi_1,$\\\textbf{\;and\;}$\Theta(\alpha,j)$\textbf{\;for all\;}$j\in L_\alpha\cup\dots\cup L_{i-1}$}
\State $Map[i]\gets\Set{\texttt{\textbf{join}[k,i]}|k\in L_\alpha\cup\dots\cup L_{i-1}}$
 
\EndIf
\EndWhile
\State $Map[i]\gets Map[i]\cup L$; 
\ForAll{$i\in \texttt{mapKey}(Map)$} \textbf{yield} $\braket{t,i,Map[i]}$
\EndFor
\EndFor
\EndFor
\EndFunction\medskip
	\end{algorithmic}
%%%%%%%%
\end{minipage}%
}% <------------- end of \resizebox
\endgroup
\end{algorithm}
\subsection{LTLf Operators' implementation on the Physical Model}