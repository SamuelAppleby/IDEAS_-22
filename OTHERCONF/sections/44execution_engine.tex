
\subsection{Execution Engine} \label{ssec:xltlf}
At the time of the writing, KnoBAB supports four different types of model aggregation queries: Conjunctive Query, Max-SAT, \textsc{Confidence}, and \textsc{Support}. As we will see at the end of the subsection, these will not require a change on the query plan, but just a different way to integrate the intermediate representation $\phi_i$ returned by each declarative clause $c_i$. 


\textit{First}, the execution engine takes both the relational database resulting from the data loading and the DAG returned by the query compiler, and uses the leaf nodes from the latter to access the former. By query plan construction, all of the relevant data parts are going to be accessed at most once and then transformed into the expected intermediate result representation. \textit{Second}, the intermediate results are propagated from the leaves towards each root node associated with a declarative clause $c_k$. Any intermediate representation is always associated with each operator returning it as a temporary primary-memory cache. Each intermediate cache  might be completely freed if we are not computing a  \textsc{Confidence} query and if the furthest ancestor has already accessed it, or if it is a cache non-associated to an activation required by \textsc{Confidence} and the furthest ancestor has already accessed it. \textit{Third}, when the computation will finish running the shallowest DAG depth level containing the \xLTLf root associated with the entry-point of each declarative clause $c_k$, each of these operators will have an intermediate result $\phi_k$ stating all the traces satisfying $c_k$.

The {Conjunctive Query} will return the traces satisfying all of the Declare clauses via the intersection of all of the clauses via \textsf{And} and \textbf{true} as a $\Theta$ condition. Max-SAT will count, for each log trace $\sigma_i$, the intermediate results $\phi_k$ associated with each clause $c_k$ containing it, and then provide the ratio of such value over the total number of the model clause $|\mathcal{M}|$. By denoting as $\textsf{ActLeaves}(\phi_k)$ the untimed union of the intermediate results returned by the activation conditions for the declare clause $c_k\in\mathcal{M}$, the \textsc{Confidence} for $c_k$ is the ratio between the total number of traces returned by $\phi_k$ and the overall traces containing an activation condition. Dividing the total number of traces returned by $\phi_k$ by the total log traces returns the \textsc{Support}. Once each $\phi_k$ per clause $c_k$ is computed, the aggregation functions can be then expressed as follows:
\[\textup{ConjQuery}(\phi_1,\dots,\phi_n)=\textsf{And}(\phi_1,\dots\textsf{And}(\phi_{n-1},\phi_n,\textbf{true}),\textbf{true})\]
\[\textup{Max-SAT}(\phi_1,\dots,\phi_n)=\left(\frac{|\Set{k|\exists j,L. \braket{i,j,L}\in\phi_k}|}{|\mathcal{M}|}\right)_{\sigma^i\in \mathcal{L}}\]
\[\textsc{Confidence}(\phi_1,\dots,\phi_n)=\left(\frac{|\Set{i|\exists j,L. \braket{i,j,L}\in \phi_k}|}{|\textsf{ActLeaves}(\phi_k)|}\right)_{c_k\in \mathcal{M}}\]
\[\textsc{Support}(\phi_1,\dots,\phi_n)=\left(\frac{|\Set{i|\exists j,L. \braket{i,j,L}\in \phi_k}|}{|\mathcal{L}|}\right)_{c_k\in \mathcal{M}}\]
As the user in \figurename~\ref{fig:knobab_pipeline} asks the ratio between satisfied clauses over the model size, the query plan exhibits a Max-SAT aggregation.

