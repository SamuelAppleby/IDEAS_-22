
\subsection{Execution Engine} \label{ssec:xltlf}
At the time of the writing, KnoBAB supports three different types of model queries: Conjunctive Query, Max-SAT, and \textit{Support}. As we will see at the end of the subsection, these will not require a change on the query plan, but just a different way to integrate the intermediate representation $\phi_i$ returned by each declarative clause $c_i$. 

\textit{First}, the execution engine takes the relational database resulting from the data loading, the DAG returned by the query compiler, and uses the leaf nodes from the latter to access the former. By query plan construction, all of the relevant data parts are going to be accessed at most once and then transformed into the expected intermediate result representation. \textit{Second}, the intermediate results are propagated from the leaves towards each root node associated to a declarative clause $c_k$. Any intermediate representations is always associated to each single returning it as a temporary primary-memory cache. Each intermediate cache  might be completely freed if we are not computing a  \textsc{Support} query and if the furthest ancestor has already accessed it, or if it is a cache non associated to an activation required by \textsc{Support} and the furthest ancestor has already access it. \textit{Third}, when the computation will finish running the highest DAG layer containing the \xLTLf root associated to the entry-point of each declarative clause $c_k$, each of these operators will have an intermediate result $\phi_k$ stating all the traces satisfying $c_k$.

The {Conjunctive Query} will return the traces satisfying all of the Declare clauses via the intersection of all of the clauses via \textsf{And} and \textbf{true} as a $\Theta$ condition. Max-SAT will count, for each log trace $\sigma_i$, the intermediate results $\phi_k$ associated to each clause $c_k$ containing it, and then provide the ratio of such value over the total number of the model clause $|\mathcal{M}|$. By denoting as $\textsf{ActLeaves}(\phi_k)$ the untimed union of the intermediate results returned by the activation conditions for the declare clause $c_k\in\mathcal{M}$, the \textsc{Support} for $c_k$ is the ration between the total number of traces returned by $\phi_k$ and the overall traces containing an activation condition. The following computations can be then expressed as follows:
\[\textup{ConjunctiveQuery}(\phi_1,\dots,\phi_n)=\textsf{And}(\phi_1,\textsf{And}(\phi_2,\dots\textsf{And}(\phi_{n-1},\phi_n,\textbf{true}),\textbf{true}),\textbf{true})\]
\[\textup{Max-SAT}(\phi_1,\dots,\phi_n)=\left(\frac{|\Set{k|\exists j,L. \braket{i,j,L}\in\phi_k}|}{|\mathcal{M}|}\right)_{\sigma^i\in \mathcal{L}}\]
\[\textup{Support}(\phi_1,\dots,\phi_n)=\left(\frac{|\Set{i|\exists j,L. \braket{i,j,L}\in \phi_k}|}{|\textsf{ActLeaves}(\phi_k)|}\right)_{c_k\in \mathcal{M}}\]



%\begin{itemize}
%	%	\item What is the input and output format for all of the operators
%	
%	%\item What does the sorting assumption guarantee at the operators' implementation level
%	
%	%\item Discuss the data operators at the leaf level for accessing data, and how do we guarantee to preserve such representation.
%	
%	%\item Describe the intuition over each operator
%	
%	%\item Last but not least, state the other composed operators that you envisioned, and claim that this works on the same assumption of relational algebra operators, where most requent operators can be merged into one single one (e.g., theta join instead of selection and join).
%	\item The semantics of the operator matches with the implementation (pseudocode), but there might differences on the algorithms being used for computing stuff efficiently.
%\end{itemize}